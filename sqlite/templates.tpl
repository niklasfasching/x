{{define "fts"}}
{{- $tokenizer := (or .tokenizer "unicode61") -}}
{{- if or (not .cols) (not .table) (not .name) }} {{ panic "table, name & cols are required" }} {{ end -}}
CREATE VIRTUAL TABLE {{ .name }} USING
  fts5({{ range $i, $col := .cols }}{{ if $i }}, {{ end }}{{ $col }}{{ end -}},
  content='{{ .table }}', content_rowid='{{ .id }}', tokenize='{{ $tokenizer }}');

CREATE VIRTUAL TABLE {{ .name}}_rows USING fts5vocab('{{ .name }}', 'row');

CREATE TRIGGER {{ .name }}_ai AFTER INSERT ON {{ .table }} BEGIN
  INSERT INTO {{ .name }}(rowid, {{ range $i, $col := .cols}}{{ if $i }}, {{ end }}{{ $col }}{{ end }})
    VALUES (new.rowid, {{ range $i, $col := .cols}}{{ if $i }}, {{ end }}new.{{ $col }}{{ end }});
END;

CREATE TRIGGER {{ .name }}_ad AFTER DELETE ON {{ .table }} BEGIN
  INSERT INTO {{ .name }}({{ .name }}, rowid, {{ range $i, $col := .cols}}{{ if $i }}, {{ end }}{{ $col }}{{ end }})
    VALUES ('delete', old.rowid, {{ range $i, $col := .cols}}{{ if $i }}, {{ end }}old.{{ $col }}{{ end }});
END;

CREATE TRIGGER {{ .name }}_au AFTER UPDATE ON {{ .table }} BEGIN
  INSERT INTO {{ .name }}({{ .name }}, rowid, {{ range $i, $col := .cols}}{{ if $i }}, {{ end }}{{ $col }}{{ end }})
    VALUES ('delete', old.rowid, {{ range $i, $col := .cols}}{{ if $i }}, {{ end }}old.{{ $col }}{{ end }});
  INSERT INTO {{ .name }}(rowid, {{ range $i, $col := .cols}}{{ if $i }}, {{ end }}{{ $col }}{{ end }})
    VALUES (new.rowid, {{ range $i, $col := .cols}}{{ if $i }}, {{ end }}new.{{ $col }}{{ end }});
END;
{{ end }}


{{ define "type-interface-methods" }}
// Code generated by x/sqlite; DO NOT EDIT.
package {{ .pkg }}

import "fmt"
import "github.com/niklasfasching/x/sqlite"

{{ range $t := .types }}
func (v {{ $t.name }}) Row() (map[string]any) {
	return map[string]any{
		{{ range $f := $t.fields -}}
		{{ if not (eq $f.Name $t.pk) -}}
		"{{ $f.Name | lower }}":
        {{- if eq $f.Kind "JSON_TEXT" -}}
		sqlite.NewJSON(&v.{{ $f.Name }}),
		{{ else -}}
		v.{{ $f.Name }},
		{{ end -}}
		{{ end }}
		{{- end -}}
	}
}


func (v {{ $t.name }}) PrimaryKey() (string, any) {
	{{- if eq $t.pk "" }}
	return "", 0
	{{- else }}
	return "{{ $t.pk}}", v.{{ $t.pk }}
	{{- end }}
}


func (v {{ $t.name }}) Cols() []string {
	return []string{
		{{- range $f := $t.fields }}
		"{{ $f.Name | lower }}",
	    {{- end }}
	}
}

func (v {{ $t.name }}) Schema() string {
	return `
    CREATE TABLE IF NOT EXISTS {{ $t.name | lower }}s (
      {{- range $i, $f := $t.fields }}
        {{ if $i }}, {{ end }}
          {{- $f.Name | lower }} {{ $f.Kind }}
            {{- $f.Extra }}
            {{- if $f.Fallback }} DEFAULT '{{ $f.Fallback }}' {{ end }}
      {{- end }}
    );
    {{ range $f := $t.fields }}
    {{ if $f.Fallback }}
    CREATE TRIGGER {{ $t.name | lower }}s_set_default_{{ $f.Name | lower }}
    AFTER UPDATE OF {{ $f.Name | lower}} ON {{ $t.name | lower }}s FOR EACH ROW
    WHEN new.{{ $f.Name | lower }} IS NULL OR new.{{ $f.Name | lower }} = 'null'
    BEGIN UPDATE {{ $t.name | lower }}s SET {{ $f.Name | lower }} = '{{ $f.Fallback}}' WHERE id = new.id; END;
    {{ end }}
    {{ end }}
`
}

func (v {{ $t.name }}) ScanRows(rows *sqlite.Rows) (any, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, err
	}
	vs, args := []{{ $t.name }}{}, make([]any, len(cols))
	for rows.Next() {
		v := *new({{ $t.name }})
		for i, c := range cols {
			switch c {
			{{- range $f := $t.fields }}
			case "{{ $f.Name | lower }}":
			{{ if eq ($f.Kind) "JSON_TEXT" -}}
				args[i] = sqlite.NewJSON(&v.{{ $f.Name }})
			{{- else -}}
				args[i] = &v.{{ $f.Name }}
			{{- end -}}
			{{ end }}
			default:
				args[i] = new(any)
			}
		}
		err := rows.Scan(args...)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}
		vs = append(vs, v)
	}
	return vs, nil
}
{{ end }}
{{ end }}
